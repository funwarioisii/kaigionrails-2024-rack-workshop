# 第2章: Rackミドルウェアをいろいろな書き方で実装してみよう

この章では、Rackミドルウェアの基本的な仕組みを理解し、さまざまな方法でミドルウェアを実装してみます。ミドルウェアを活用することで、アプリケーションの機能を拡張したり、共通の処理を分離することができます。

---

## 1. Rackミドルウェアとは

Rackミドルウェアは、Rackアプリケーションのリクエストとレスポンスの間に介在し、リクエストを加工したり、レスポンスに処理を加えたりするコンポーネントです。ミドルウェアをチェーンのようにつなげることで、複雑な処理をシンプルに組み立てることができます。

---

## 2. シンプルなミドルウェアの作成

まずは、簡単なミドルウェアを作成してみましょう。レスポンスヘッダーにカスタムヘッダーを追加するミドルウェアを実装します。

### 手順

1. 新しいファイル `01-plain.ru` を作成します。

2. 基本的なRackアプリケーションを定義します。

```ruby
class App
  def call(env)
    # ステータスコード、ヘッダー、ボディを返す
  end
end
```

3. `App` クラスの `call` メソッドでは、ステータスコード200、ヘッダーは空のハッシュ、ボディは `'hello'` を含む配列を返すように実装します。

4. 次に、ミドルウェアクラス `Middleware` を定義します。

```ruby
class Middleware
  def initialize(app, kaigion)
    # 初期化処理
  end

  def call(env)
    # ミドルウェアの処理
  end
end
```

5. `initialize` メソッドでは、アプリケーションを受け取り、インスタンス変数 `@app` に保存します。また、カスタムヘッダーの値 `kaigion` も受け取って `@kaigion` に保存します。

6. `call` メソッドでは、`@app.call(env)` を呼び出して、元のアプリケーションのレスポンスを取得します。その後、ヘッダーに `kaigi-on` というキーで `@kaigion` の値を追加します。

7. ミドルウェアを使用するために、`use Middleware, "rails"` を記述します。

8. 最後に、`run App.new` でアプリケーションを実行します。

### ポイント

- ミドルウェアは、`initialize` と `call` メソッドを持つクラスで定義します。
- `initialize` メソッドで、次のアプリケーションやミドルウェアを受け取ります。
- `call` メソッドで、リクエストを処理し、レスポンスを加工します。
- `use` キーワードを使ってミドルウェアを登録します。

### 実行方法

ターミナルで以下のコマンドを実行します。

```bash
rackup 01-plain.ru
```

ブラウザで `http://localhost:9292` にアクセスし、開発者ツールのネットワークタブでレスポンスヘッダーを確認すると、`kaigi-on` ヘッダーが追加されていることがわかります。

---

## 3. Rackの標準ミドルウェアを活用する

Rackが提供する標準のミドルウェアを使って、機能を拡張してみましょう。ここでは、リクエストの処理時間を測定する `Rack::Runtime` と、Basic認証を行う `Rack::Auth::Basic` を使用します。

### 手順

1. 新しいファイル `02-library.ru` を作成します。

2. 必要なライブラリを読み込みます。

```ruby
require 'rack/response'
require 'rack/runtime'
require 'rack/auth/basic'
```

3. 前のステップで作成した `App` クラスと `Middleware` クラスを定義します。

4. `App` クラスの `call` メソッドでは、`Rack::Response` を使ってレスポンスを返します。

```ruby
class App
  def call(env)
    # Rack::Responseを使用してレスポンスを生成
  end
end
```

5. ミドルウェアを追加します。

```ruby
use Middleware, "rails"
use Rack::Runtime
use Rack::Auth::Basic do |username, password|
  # 認証の条件
end
```

6. `Rack::Auth::Basic` のブロック内で、ユーザー名とパスワードのチェックを行います。例えば、ユーザー名が `"rubyist"`、パスワードが `"onrack"` の場合に認証を通過させます。

7. 最後に、`run App.new` でアプリケーションを実行します。

### ポイント

- `Rack::Runtime` はリクエストの処理時間を計測し、レスポンスヘッダーに `X-Runtime` を追加します。
- `Rack::Auth::Basic` はBasic認証を実装するミドルウェアです。ブロック内で認証ロジックを定義します。
- ミドルウェアは上から順に適用されます。

### 実行方法

```bash
rackup 02-library.ru
```

ブラウザで `http://localhost:9292` にアクセスすると、認証ダイアログが表示されます。ユーザー名に `"rubyist"`、パスワードに `"onrack"` を入力すると、`hello!` が表示されます。レスポンスヘッダーに `X-Runtime`（処理時間）と `kaigi-on` ヘッダーが追加されていることを確認しましょう。

---

## 4. Sinatraとミドルウェアの組み合わせ

最後に、Sinatraアプリケーションにミドルウェアを適用してみます。これにより、Sinatraの機能とRackミドルウェアの組み合わせ方を理解します。

### 手順

1. 新しいファイル `03-sinatra.ru` を作成します。

2. 必要なライブラリを読み込みます。

```ruby
require 'sinatra/base'
require 'rack/runtime'
require 'rack/auth/basic'
```

3. Sinatraのベースクラスを継承した `App` クラスを定義します。

```ruby
class App < Sinatra::Base
  get '/' do
    # レスポンスを返す
  end

  get '/hello/:id' do
    # レスポンスを返す
  end
end
```

4. ルート `/` では `"It works!"`、ルート `/hello/:id` では `"Hello #{params[:id]}"` を返すように実装します。

5. ミドルウェアを追加します。

```ruby
use Rack::Runtime
use Rack::Auth::Basic do |username, password|
  # 認証の条件
end
```

6. 認証の条件は前と同じく、ユーザー名が `"rubyist"`、パスワードが `"onrack"` の場合に通過させます。

7. 最後に、`run App.new` でアプリケーションを実行します。

### ポイント

- Sinatraアプリケーションでも、`use` キーワードを使ってRackミドルウェアを適用できます。
- ミドルウェアはSinatraのルートが処理される前に適用されます。
- `params` ハッシュを使って、ルートパラメータを取得できます。

### 実行方法

```bash
rackup 03-sinatra.ru
```

ブラウザで `http://localhost:9292/` や `http://localhost:9292/hello/123` にアクセスし、認証を通過してからレスポンスが返されることを確認します。レスポンスヘッダーには `X-Runtime` が含まれています。

---

## 5. まとめ

この章では、Rackミドルウェアの基本的な実装方法から、Rackの標準ミドルウェアの活用、そしてSinatraアプリケーションへのミドルウェア適用までを学びました。ミドルウェアを使うことで、共通の処理をアプリケーションから分離し、再利用性や保守性を向上させることができます。

これまでの内容を通じて、以下のポイントを理解できたと思います。

- **ミドルウェアの基本構造**: `initialize` と `call` メソッドを持つクラス。
- **ミドルウェアの適用順序**: `use` キーワードで上から順に適用される。
- **Rackの標準ミドルウェア**: `Rack::Runtime` や `Rack::Auth::Basic` などの活用方法。
- **Sinatraとの組み合わせ**: Sinatraアプリケーションにミドルウェアを適用する方法。

これらの知識を基に、より複雑なミドルウェアやアプリケーションを作成してみてください。

---

次の章では、ミドルウェアを使った高度な機能の実装や、エラーハンドリング、ロギングなどについて学んでいきます。